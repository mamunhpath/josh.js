/**
 * Josh.js - A JavaScript library to animate content on page scroll.
 * Version: 1.0.0
 * Author: Al Mamun
 * License: MIT
 * Repo: https://github.com/mamunhpath/josh.js
 * Demo: https://mamunhpath.github.io/josh.js
 */

"use strict"; var _createClass = function () { function e(e, t) { for (var i = 0; i < t.length; i++){ var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, i, n) { return i && e(t.prototype, i), n && e(t, n), t } }(); function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } var Josh = function () { function e() { var t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0]; _classCallCheck(this, e), this.initClass = t.initClass || "josh-js", this.initDom = document.querySelectorAll("." + this.initClass), this.animClass = t.animClass || "animate__animated", this.offset = t.offset || .2, this.animateInMobile = void 0 === t.animateInMobile || t.animateInMobile, this.onDOMChange = void 0 !== t.onDOMChange && t.onDOMChange, this.intersectOnScroll(this.initDom), this.callOnDOMChange(), this.addCss(this.initDom) } return _createClass(e, [{ key: "intersectionObserverCallback", value: function (e, t) { var i = !this.animateInMobile && this.isMobile(); e.forEach(function (e) { var n = e.target, s = n.dataset.joshAnimName, a = n.dataset.joshIteration, o = n.dataset.joshDuration, r = n.dataset.joshDelay; if (e.isIntersecting) { var l = "visibility: visible;animation-name: " + s + ";animation-duration: " + o + ";animation-iteration-count: " + a + ";animation-delay: " + r + ";"; i || (n.style = n.style.cssText + l), t.unobserve(n) } }) } }, { key: "addCss", value: function (e) { var t = this; e.length > 0 ? e.forEach(function (e) { t.cssUtil(e) }) : this.cssUtil(e) } }, { key: "cssUtil", value: function (e) { var t = !this.animateInMobile && this.isMobile(); e.classList.add(this.animClass), t || (e.style = e.style.cssText + "visibility: hidden") } }, { key: "intersectOnScroll", value: function (e) { var t, i = this; if (!("IntersectionObserver" in window)) throw new Error("IntersectionObserver is not support by this browser. Try by adding pollyfil or use other library."); t = new IntersectionObserver(i.intersectionObserverCallback.bind(i), { root: null, rootMargin: "0px", threshold: i.offset }), e.length > 0 ? e.forEach(function (e) { t.observe(e) }) : t.observe(e) } }, { key: "callOnDOMChange", value: function () { var e = this; window.addEventListener("DOMContentLoaded", function () { if (e.onDOMChange) { new MutationObserver(function (t) { t.forEach(function (t) { var i = t.addedNodes; null !== i && i.forEach(function (t) { e.addCss(t), e.intersectOnScroll(t) }) }) }).observe(document.body, { childList: !0, subtree: !0 }) } }) } }, { key: "isMobile", value: function () { return /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) } }]), e }();